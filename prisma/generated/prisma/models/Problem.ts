/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Problem` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums.js";
import type * as Prisma from "../internal/prismaNamespace.js";

/**
 * Model Problem
 *
 */
export type ProblemModel =
  runtime.Types.Result.DefaultSelection<Prisma.$ProblemPayload>;

export type AggregateProblem = {
  _count: ProblemCountAggregateOutputType | null;
  _avg: ProblemAvgAggregateOutputType | null;
  _sum: ProblemSumAggregateOutputType | null;
  _min: ProblemMinAggregateOutputType | null;
  _max: ProblemMaxAggregateOutputType | null;
};

export type ProblemAvgAggregateOutputType = {
  timeLimitInSeconds: number | null;
  memoryLimitInMB: number | null;
  views: number | null;
  acceptedSubmissions: number | null;
  totalSubmissions: number | null;
};

export type ProblemSumAggregateOutputType = {
  timeLimitInSeconds: number | null;
  memoryLimitInMB: number | null;
  views: number | null;
  acceptedSubmissions: number | null;
  totalSubmissions: number | null;
};

export type ProblemMinAggregateOutputType = {
  id: string | null;
  title: string | null;
  slug: string | null;
  description: string | null;
  createdById: string | null;
  timeLimitInSeconds: number | null;
  memoryLimitInMB: number | null;
  views: number | null;
  acceptedSubmissions: number | null;
  totalSubmissions: number | null;
  difficulty: $Enums.Difficulty | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

export type ProblemMaxAggregateOutputType = {
  id: string | null;
  title: string | null;
  slug: string | null;
  description: string | null;
  createdById: string | null;
  timeLimitInSeconds: number | null;
  memoryLimitInMB: number | null;
  views: number | null;
  acceptedSubmissions: number | null;
  totalSubmissions: number | null;
  difficulty: $Enums.Difficulty | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

export type ProblemCountAggregateOutputType = {
  id: number;
  title: number;
  slug: number;
  description: number;
  createdById: number;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views: number;
  acceptedSubmissions: number;
  totalSubmissions: number;
  difficulty: number;
  createdAt: number;
  updatedAt: number;
  _all: number;
};

export type ProblemAvgAggregateInputType = {
  timeLimitInSeconds?: true;
  memoryLimitInMB?: true;
  views?: true;
  acceptedSubmissions?: true;
  totalSubmissions?: true;
};

export type ProblemSumAggregateInputType = {
  timeLimitInSeconds?: true;
  memoryLimitInMB?: true;
  views?: true;
  acceptedSubmissions?: true;
  totalSubmissions?: true;
};

export type ProblemMinAggregateInputType = {
  id?: true;
  title?: true;
  slug?: true;
  description?: true;
  createdById?: true;
  timeLimitInSeconds?: true;
  memoryLimitInMB?: true;
  views?: true;
  acceptedSubmissions?: true;
  totalSubmissions?: true;
  difficulty?: true;
  createdAt?: true;
  updatedAt?: true;
};

export type ProblemMaxAggregateInputType = {
  id?: true;
  title?: true;
  slug?: true;
  description?: true;
  createdById?: true;
  timeLimitInSeconds?: true;
  memoryLimitInMB?: true;
  views?: true;
  acceptedSubmissions?: true;
  totalSubmissions?: true;
  difficulty?: true;
  createdAt?: true;
  updatedAt?: true;
};

export type ProblemCountAggregateInputType = {
  id?: true;
  title?: true;
  slug?: true;
  description?: true;
  createdById?: true;
  timeLimitInSeconds?: true;
  memoryLimitInMB?: true;
  views?: true;
  acceptedSubmissions?: true;
  totalSubmissions?: true;
  difficulty?: true;
  createdAt?: true;
  updatedAt?: true;
  _all?: true;
};

export type ProblemAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Problem to aggregate.
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Problems to fetch.
   */
  orderBy?:
    | Prisma.ProblemOrderByWithRelationInput
    | Prisma.ProblemOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.ProblemWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Problems from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Problems.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Problems
   **/
  _count?: true | ProblemCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to average
   **/
  _avg?: ProblemAvgAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to sum
   **/
  _sum?: ProblemSumAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: ProblemMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: ProblemMaxAggregateInputType;
};

export type GetProblemAggregateType<T extends ProblemAggregateArgs> = {
  [P in keyof T & keyof AggregateProblem]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProblem[P]>
    : Prisma.GetScalarType<T[P], AggregateProblem[P]>;
};

export type ProblemGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ProblemWhereInput;
  orderBy?:
    | Prisma.ProblemOrderByWithAggregationInput
    | Prisma.ProblemOrderByWithAggregationInput[];
  by: Prisma.ProblemScalarFieldEnum[] | Prisma.ProblemScalarFieldEnum;
  having?: Prisma.ProblemScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: ProblemCountAggregateInputType | true;
  _avg?: ProblemAvgAggregateInputType;
  _sum?: ProblemSumAggregateInputType;
  _min?: ProblemMinAggregateInputType;
  _max?: ProblemMaxAggregateInputType;
};

export type ProblemGroupByOutputType = {
  id: string;
  title: string;
  slug: string;
  description: string;
  createdById: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views: number;
  acceptedSubmissions: number;
  totalSubmissions: number;
  difficulty: $Enums.Difficulty;
  createdAt: Date;
  updatedAt: Date;
  _count: ProblemCountAggregateOutputType | null;
  _avg: ProblemAvgAggregateOutputType | null;
  _sum: ProblemSumAggregateOutputType | null;
  _min: ProblemMinAggregateOutputType | null;
  _max: ProblemMaxAggregateOutputType | null;
};

type GetProblemGroupByPayload<T extends ProblemGroupByArgs> =
  Prisma.PrismaPromise<
    Array<
      Prisma.PickEnumerable<ProblemGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ProblemGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProblemGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProblemGroupByOutputType[P]>;
      }
    >
  >;

export type ProblemWhereInput = {
  AND?: Prisma.ProblemWhereInput | Prisma.ProblemWhereInput[];
  OR?: Prisma.ProblemWhereInput[];
  NOT?: Prisma.ProblemWhereInput | Prisma.ProblemWhereInput[];
  id?: Prisma.StringFilter<"Problem"> | string;
  title?: Prisma.StringFilter<"Problem"> | string;
  slug?: Prisma.StringFilter<"Problem"> | string;
  description?: Prisma.StringFilter<"Problem"> | string;
  createdById?: Prisma.StringNullableFilter<"Problem"> | string | null;
  timeLimitInSeconds?: Prisma.IntFilter<"Problem"> | number;
  memoryLimitInMB?: Prisma.IntFilter<"Problem"> | number;
  views?: Prisma.IntFilter<"Problem"> | number;
  acceptedSubmissions?: Prisma.IntFilter<"Problem"> | number;
  totalSubmissions?: Prisma.IntFilter<"Problem"> | number;
  difficulty?: Prisma.EnumDifficultyFilter<"Problem"> | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFilter<"Problem"> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<"Problem"> | Date | string;
  examples?: Prisma.ExampleListRelationFilter;
  createdBy?: Prisma.XOR<
    Prisma.UserNullableScalarRelationFilter,
    Prisma.UserWhereInput
  > | null;
  solutions?: Prisma.SolutionListRelationFilter;
  submissions?: Prisma.SubmissionListRelationFilter;
  userSolutions?: Prisma.UserSolutionListRelationFilter;
  hints?: Prisma.HintListRelationFilter;
  topics?: Prisma.TopicListRelationFilter;
  editorial?: Prisma.XOR<
    Prisma.EditorialNullableScalarRelationFilter,
    Prisma.EditorialWhereInput
  > | null;
  discussions?: Prisma.DiscussionListRelationFilter;
  problemInteraction?: Prisma.ProblemInteractionListRelationFilter;
  bookmarkedProblems?: Prisma.BookmarkedProblemListRelationFilter;
  testcases?: Prisma.TestcaseListRelationFilter;
};

export type ProblemOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  slug?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  createdById?: Prisma.SortOrderInput | Prisma.SortOrder;
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
  difficulty?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  examples?: Prisma.ExampleOrderByRelationAggregateInput;
  createdBy?: Prisma.UserOrderByWithRelationInput;
  solutions?: Prisma.SolutionOrderByRelationAggregateInput;
  submissions?: Prisma.SubmissionOrderByRelationAggregateInput;
  userSolutions?: Prisma.UserSolutionOrderByRelationAggregateInput;
  hints?: Prisma.HintOrderByRelationAggregateInput;
  topics?: Prisma.TopicOrderByRelationAggregateInput;
  editorial?: Prisma.EditorialOrderByWithRelationInput;
  discussions?: Prisma.DiscussionOrderByRelationAggregateInput;
  problemInteraction?: Prisma.ProblemInteractionOrderByRelationAggregateInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemOrderByRelationAggregateInput;
  testcases?: Prisma.TestcaseOrderByRelationAggregateInput;
};

export type ProblemWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    slug?: string;
    AND?: Prisma.ProblemWhereInput | Prisma.ProblemWhereInput[];
    OR?: Prisma.ProblemWhereInput[];
    NOT?: Prisma.ProblemWhereInput | Prisma.ProblemWhereInput[];
    title?: Prisma.StringFilter<"Problem"> | string;
    description?: Prisma.StringFilter<"Problem"> | string;
    createdById?: Prisma.StringNullableFilter<"Problem"> | string | null;
    timeLimitInSeconds?: Prisma.IntFilter<"Problem"> | number;
    memoryLimitInMB?: Prisma.IntFilter<"Problem"> | number;
    views?: Prisma.IntFilter<"Problem"> | number;
    acceptedSubmissions?: Prisma.IntFilter<"Problem"> | number;
    totalSubmissions?: Prisma.IntFilter<"Problem"> | number;
    difficulty?: Prisma.EnumDifficultyFilter<"Problem"> | $Enums.Difficulty;
    createdAt?: Prisma.DateTimeFilter<"Problem"> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<"Problem"> | Date | string;
    examples?: Prisma.ExampleListRelationFilter;
    createdBy?: Prisma.XOR<
      Prisma.UserNullableScalarRelationFilter,
      Prisma.UserWhereInput
    > | null;
    solutions?: Prisma.SolutionListRelationFilter;
    submissions?: Prisma.SubmissionListRelationFilter;
    userSolutions?: Prisma.UserSolutionListRelationFilter;
    hints?: Prisma.HintListRelationFilter;
    topics?: Prisma.TopicListRelationFilter;
    editorial?: Prisma.XOR<
      Prisma.EditorialNullableScalarRelationFilter,
      Prisma.EditorialWhereInput
    > | null;
    discussions?: Prisma.DiscussionListRelationFilter;
    problemInteraction?: Prisma.ProblemInteractionListRelationFilter;
    bookmarkedProblems?: Prisma.BookmarkedProblemListRelationFilter;
    testcases?: Prisma.TestcaseListRelationFilter;
  },
  "id" | "slug"
>;

export type ProblemOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  slug?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  createdById?: Prisma.SortOrderInput | Prisma.SortOrder;
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
  difficulty?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  _count?: Prisma.ProblemCountOrderByAggregateInput;
  _avg?: Prisma.ProblemAvgOrderByAggregateInput;
  _max?: Prisma.ProblemMaxOrderByAggregateInput;
  _min?: Prisma.ProblemMinOrderByAggregateInput;
  _sum?: Prisma.ProblemSumOrderByAggregateInput;
};

export type ProblemScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.ProblemScalarWhereWithAggregatesInput
    | Prisma.ProblemScalarWhereWithAggregatesInput[];
  OR?: Prisma.ProblemScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.ProblemScalarWhereWithAggregatesInput
    | Prisma.ProblemScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<"Problem"> | string;
  title?: Prisma.StringWithAggregatesFilter<"Problem"> | string;
  slug?: Prisma.StringWithAggregatesFilter<"Problem"> | string;
  description?: Prisma.StringWithAggregatesFilter<"Problem"> | string;
  createdById?:
    | Prisma.StringNullableWithAggregatesFilter<"Problem">
    | string
    | null;
  timeLimitInSeconds?: Prisma.IntWithAggregatesFilter<"Problem"> | number;
  memoryLimitInMB?: Prisma.IntWithAggregatesFilter<"Problem"> | number;
  views?: Prisma.IntWithAggregatesFilter<"Problem"> | number;
  acceptedSubmissions?: Prisma.IntWithAggregatesFilter<"Problem"> | number;
  totalSubmissions?: Prisma.IntWithAggregatesFilter<"Problem"> | number;
  difficulty?:
    | Prisma.EnumDifficultyWithAggregatesFilter<"Problem">
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Problem"> | Date | string;
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Problem"> | Date | string;
};

export type ProblemCreateInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateManyInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type ProblemUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ProblemUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ProblemListRelationFilter = {
  every?: Prisma.ProblemWhereInput;
  some?: Prisma.ProblemWhereInput;
  none?: Prisma.ProblemWhereInput;
};

export type ProblemOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type ProblemCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  slug?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  createdById?: Prisma.SortOrder;
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
  difficulty?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type ProblemAvgOrderByAggregateInput = {
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
};

export type ProblemMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  slug?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  createdById?: Prisma.SortOrder;
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
  difficulty?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type ProblemMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  title?: Prisma.SortOrder;
  slug?: Prisma.SortOrder;
  description?: Prisma.SortOrder;
  createdById?: Prisma.SortOrder;
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
  difficulty?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type ProblemSumOrderByAggregateInput = {
  timeLimitInSeconds?: Prisma.SortOrder;
  memoryLimitInMB?: Prisma.SortOrder;
  views?: Prisma.SortOrder;
  acceptedSubmissions?: Prisma.SortOrder;
  totalSubmissions?: Prisma.SortOrder;
};

export type ProblemScalarRelationFilter = {
  is?: Prisma.ProblemWhereInput;
  isNot?: Prisma.ProblemWhereInput;
};

export type ProblemCreateNestedManyWithoutCreatedByInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutCreatedByInput,
        Prisma.ProblemUncheckedCreateWithoutCreatedByInput
      >
    | Prisma.ProblemCreateWithoutCreatedByInput[]
    | Prisma.ProblemUncheckedCreateWithoutCreatedByInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput[];
  createMany?: Prisma.ProblemCreateManyCreatedByInputEnvelope;
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
};

export type ProblemUncheckedCreateNestedManyWithoutCreatedByInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutCreatedByInput,
        Prisma.ProblemUncheckedCreateWithoutCreatedByInput
      >
    | Prisma.ProblemCreateWithoutCreatedByInput[]
    | Prisma.ProblemUncheckedCreateWithoutCreatedByInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput[];
  createMany?: Prisma.ProblemCreateManyCreatedByInputEnvelope;
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
};

export type ProblemUpdateManyWithoutCreatedByNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutCreatedByInput,
        Prisma.ProblemUncheckedCreateWithoutCreatedByInput
      >
    | Prisma.ProblemCreateWithoutCreatedByInput[]
    | Prisma.ProblemUncheckedCreateWithoutCreatedByInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput[];
  upsert?:
    | Prisma.ProblemUpsertWithWhereUniqueWithoutCreatedByInput
    | Prisma.ProblemUpsertWithWhereUniqueWithoutCreatedByInput[];
  createMany?: Prisma.ProblemCreateManyCreatedByInputEnvelope;
  set?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  disconnect?:
    | Prisma.ProblemWhereUniqueInput
    | Prisma.ProblemWhereUniqueInput[];
  delete?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  update?:
    | Prisma.ProblemUpdateWithWhereUniqueWithoutCreatedByInput
    | Prisma.ProblemUpdateWithWhereUniqueWithoutCreatedByInput[];
  updateMany?:
    | Prisma.ProblemUpdateManyWithWhereWithoutCreatedByInput
    | Prisma.ProblemUpdateManyWithWhereWithoutCreatedByInput[];
  deleteMany?:
    | Prisma.ProblemScalarWhereInput
    | Prisma.ProblemScalarWhereInput[];
};

export type ProblemUncheckedUpdateManyWithoutCreatedByNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutCreatedByInput,
        Prisma.ProblemUncheckedCreateWithoutCreatedByInput
      >
    | Prisma.ProblemCreateWithoutCreatedByInput[]
    | Prisma.ProblemUncheckedCreateWithoutCreatedByInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput
    | Prisma.ProblemCreateOrConnectWithoutCreatedByInput[];
  upsert?:
    | Prisma.ProblemUpsertWithWhereUniqueWithoutCreatedByInput
    | Prisma.ProblemUpsertWithWhereUniqueWithoutCreatedByInput[];
  createMany?: Prisma.ProblemCreateManyCreatedByInputEnvelope;
  set?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  disconnect?:
    | Prisma.ProblemWhereUniqueInput
    | Prisma.ProblemWhereUniqueInput[];
  delete?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  update?:
    | Prisma.ProblemUpdateWithWhereUniqueWithoutCreatedByInput
    | Prisma.ProblemUpdateWithWhereUniqueWithoutCreatedByInput[];
  updateMany?:
    | Prisma.ProblemUpdateManyWithWhereWithoutCreatedByInput
    | Prisma.ProblemUpdateManyWithWhereWithoutCreatedByInput[];
  deleteMany?:
    | Prisma.ProblemScalarWhereInput
    | Prisma.ProblemScalarWhereInput[];
};

export type IntFieldUpdateOperationsInput = {
  set?: number;
  increment?: number;
  decrement?: number;
  multiply?: number;
  divide?: number;
};

export type EnumDifficultyFieldUpdateOperationsInput = {
  set?: $Enums.Difficulty;
};

export type ProblemCreateNestedOneWithoutTestcasesInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutTestcasesInput,
    Prisma.ProblemUncheckedCreateWithoutTestcasesInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutTestcasesInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutTestcasesNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutTestcasesInput,
    Prisma.ProblemUncheckedCreateWithoutTestcasesInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutTestcasesInput;
  upsert?: Prisma.ProblemUpsertWithoutTestcasesInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutTestcasesInput,
      Prisma.ProblemUpdateWithoutTestcasesInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutTestcasesInput
  >;
};

export type ProblemCreateNestedOneWithoutHintsInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutHintsInput,
    Prisma.ProblemUncheckedCreateWithoutHintsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutHintsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutHintsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutHintsInput,
    Prisma.ProblemUncheckedCreateWithoutHintsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutHintsInput;
  upsert?: Prisma.ProblemUpsertWithoutHintsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutHintsInput,
      Prisma.ProblemUpdateWithoutHintsInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutHintsInput
  >;
};

export type ProblemCreateNestedManyWithoutTopicsInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutTopicsInput,
        Prisma.ProblemUncheckedCreateWithoutTopicsInput
      >
    | Prisma.ProblemCreateWithoutTopicsInput[]
    | Prisma.ProblemUncheckedCreateWithoutTopicsInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput[];
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
};

export type ProblemUncheckedCreateNestedManyWithoutTopicsInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutTopicsInput,
        Prisma.ProblemUncheckedCreateWithoutTopicsInput
      >
    | Prisma.ProblemCreateWithoutTopicsInput[]
    | Prisma.ProblemUncheckedCreateWithoutTopicsInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput[];
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
};

export type ProblemUpdateManyWithoutTopicsNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutTopicsInput,
        Prisma.ProblemUncheckedCreateWithoutTopicsInput
      >
    | Prisma.ProblemCreateWithoutTopicsInput[]
    | Prisma.ProblemUncheckedCreateWithoutTopicsInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput[];
  upsert?:
    | Prisma.ProblemUpsertWithWhereUniqueWithoutTopicsInput
    | Prisma.ProblemUpsertWithWhereUniqueWithoutTopicsInput[];
  set?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  disconnect?:
    | Prisma.ProblemWhereUniqueInput
    | Prisma.ProblemWhereUniqueInput[];
  delete?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  update?:
    | Prisma.ProblemUpdateWithWhereUniqueWithoutTopicsInput
    | Prisma.ProblemUpdateWithWhereUniqueWithoutTopicsInput[];
  updateMany?:
    | Prisma.ProblemUpdateManyWithWhereWithoutTopicsInput
    | Prisma.ProblemUpdateManyWithWhereWithoutTopicsInput[];
  deleteMany?:
    | Prisma.ProblemScalarWhereInput
    | Prisma.ProblemScalarWhereInput[];
};

export type ProblemUncheckedUpdateManyWithoutTopicsNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.ProblemCreateWithoutTopicsInput,
        Prisma.ProblemUncheckedCreateWithoutTopicsInput
      >
    | Prisma.ProblemCreateWithoutTopicsInput[]
    | Prisma.ProblemUncheckedCreateWithoutTopicsInput[];
  connectOrCreate?:
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput
    | Prisma.ProblemCreateOrConnectWithoutTopicsInput[];
  upsert?:
    | Prisma.ProblemUpsertWithWhereUniqueWithoutTopicsInput
    | Prisma.ProblemUpsertWithWhereUniqueWithoutTopicsInput[];
  set?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  disconnect?:
    | Prisma.ProblemWhereUniqueInput
    | Prisma.ProblemWhereUniqueInput[];
  delete?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  connect?: Prisma.ProblemWhereUniqueInput | Prisma.ProblemWhereUniqueInput[];
  update?:
    | Prisma.ProblemUpdateWithWhereUniqueWithoutTopicsInput
    | Prisma.ProblemUpdateWithWhereUniqueWithoutTopicsInput[];
  updateMany?:
    | Prisma.ProblemUpdateManyWithWhereWithoutTopicsInput
    | Prisma.ProblemUpdateManyWithWhereWithoutTopicsInput[];
  deleteMany?:
    | Prisma.ProblemScalarWhereInput
    | Prisma.ProblemScalarWhereInput[];
};

export type ProblemCreateNestedOneWithoutProblemInteractionInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutProblemInteractionInput,
    Prisma.ProblemUncheckedCreateWithoutProblemInteractionInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutProblemInteractionInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutProblemInteractionNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutProblemInteractionInput,
    Prisma.ProblemUncheckedCreateWithoutProblemInteractionInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutProblemInteractionInput;
  upsert?: Prisma.ProblemUpsertWithoutProblemInteractionInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutProblemInteractionInput,
      Prisma.ProblemUpdateWithoutProblemInteractionInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutProblemInteractionInput
  >;
};

export type ProblemCreateNestedOneWithoutBookmarkedProblemsInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutBookmarkedProblemsInput,
    Prisma.ProblemUncheckedCreateWithoutBookmarkedProblemsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutBookmarkedProblemsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutBookmarkedProblemsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutBookmarkedProblemsInput,
    Prisma.ProblemUncheckedCreateWithoutBookmarkedProblemsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutBookmarkedProblemsInput;
  upsert?: Prisma.ProblemUpsertWithoutBookmarkedProblemsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutBookmarkedProblemsInput,
      Prisma.ProblemUpdateWithoutBookmarkedProblemsInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutBookmarkedProblemsInput
  >;
};

export type ProblemCreateNestedOneWithoutExamplesInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutExamplesInput,
    Prisma.ProblemUncheckedCreateWithoutExamplesInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutExamplesInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutExamplesNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutExamplesInput,
    Prisma.ProblemUncheckedCreateWithoutExamplesInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutExamplesInput;
  upsert?: Prisma.ProblemUpsertWithoutExamplesInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutExamplesInput,
      Prisma.ProblemUpdateWithoutExamplesInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutExamplesInput
  >;
};

export type ProblemCreateNestedOneWithoutSolutionsInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutSolutionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutSolutionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutSolutionsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutSolutionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutSolutionsInput;
  upsert?: Prisma.ProblemUpsertWithoutSolutionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutSolutionsInput,
      Prisma.ProblemUpdateWithoutSolutionsInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutSolutionsInput
  >;
};

export type ProblemCreateNestedOneWithoutSubmissionsInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutSubmissionsInput,
    Prisma.ProblemUncheckedCreateWithoutSubmissionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutSubmissionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutSubmissionsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutSubmissionsInput,
    Prisma.ProblemUncheckedCreateWithoutSubmissionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutSubmissionsInput;
  upsert?: Prisma.ProblemUpsertWithoutSubmissionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutSubmissionsInput,
      Prisma.ProblemUpdateWithoutSubmissionsInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutSubmissionsInput
  >;
};

export type ProblemCreateNestedOneWithoutUserSolutionsInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutUserSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutUserSolutionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutUserSolutionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutUserSolutionsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutUserSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutUserSolutionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutUserSolutionsInput;
  upsert?: Prisma.ProblemUpsertWithoutUserSolutionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutUserSolutionsInput,
      Prisma.ProblemUpdateWithoutUserSolutionsInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutUserSolutionsInput
  >;
};

export type ProblemCreateNestedOneWithoutEditorialInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutEditorialInput,
    Prisma.ProblemUncheckedCreateWithoutEditorialInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutEditorialInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutEditorialNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutEditorialInput,
    Prisma.ProblemUncheckedCreateWithoutEditorialInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutEditorialInput;
  upsert?: Prisma.ProblemUpsertWithoutEditorialInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutEditorialInput,
      Prisma.ProblemUpdateWithoutEditorialInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutEditorialInput
  >;
};

export type ProblemCreateNestedOneWithoutDiscussionsInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutDiscussionsInput,
    Prisma.ProblemUncheckedCreateWithoutDiscussionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutDiscussionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
};

export type ProblemUpdateOneRequiredWithoutDiscussionsNestedInput = {
  create?: Prisma.XOR<
    Prisma.ProblemCreateWithoutDiscussionsInput,
    Prisma.ProblemUncheckedCreateWithoutDiscussionsInput
  >;
  connectOrCreate?: Prisma.ProblemCreateOrConnectWithoutDiscussionsInput;
  upsert?: Prisma.ProblemUpsertWithoutDiscussionsInput;
  connect?: Prisma.ProblemWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ProblemUpdateToOneWithWhereWithoutDiscussionsInput,
      Prisma.ProblemUpdateWithoutDiscussionsInput
    >,
    Prisma.ProblemUncheckedUpdateWithoutDiscussionsInput
  >;
};

export type ProblemCreateWithoutCreatedByInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutCreatedByInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutCreatedByInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutCreatedByInput,
    Prisma.ProblemUncheckedCreateWithoutCreatedByInput
  >;
};

export type ProblemCreateManyCreatedByInputEnvelope = {
  data:
    | Prisma.ProblemCreateManyCreatedByInput
    | Prisma.ProblemCreateManyCreatedByInput[];
  skipDuplicates?: boolean;
};

export type ProblemUpsertWithWhereUniqueWithoutCreatedByInput = {
  where: Prisma.ProblemWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutCreatedByInput,
    Prisma.ProblemUncheckedUpdateWithoutCreatedByInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutCreatedByInput,
    Prisma.ProblemUncheckedCreateWithoutCreatedByInput
  >;
};

export type ProblemUpdateWithWhereUniqueWithoutCreatedByInput = {
  where: Prisma.ProblemWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutCreatedByInput,
    Prisma.ProblemUncheckedUpdateWithoutCreatedByInput
  >;
};

export type ProblemUpdateManyWithWhereWithoutCreatedByInput = {
  where: Prisma.ProblemScalarWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateManyMutationInput,
    Prisma.ProblemUncheckedUpdateManyWithoutCreatedByInput
  >;
};

export type ProblemScalarWhereInput = {
  AND?: Prisma.ProblemScalarWhereInput | Prisma.ProblemScalarWhereInput[];
  OR?: Prisma.ProblemScalarWhereInput[];
  NOT?: Prisma.ProblemScalarWhereInput | Prisma.ProblemScalarWhereInput[];
  id?: Prisma.StringFilter<"Problem"> | string;
  title?: Prisma.StringFilter<"Problem"> | string;
  slug?: Prisma.StringFilter<"Problem"> | string;
  description?: Prisma.StringFilter<"Problem"> | string;
  createdById?: Prisma.StringNullableFilter<"Problem"> | string | null;
  timeLimitInSeconds?: Prisma.IntFilter<"Problem"> | number;
  memoryLimitInMB?: Prisma.IntFilter<"Problem"> | number;
  views?: Prisma.IntFilter<"Problem"> | number;
  acceptedSubmissions?: Prisma.IntFilter<"Problem"> | number;
  totalSubmissions?: Prisma.IntFilter<"Problem"> | number;
  difficulty?: Prisma.EnumDifficultyFilter<"Problem"> | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFilter<"Problem"> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<"Problem"> | Date | string;
};

export type ProblemCreateWithoutTestcasesInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutTestcasesInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutTestcasesInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutTestcasesInput,
    Prisma.ProblemUncheckedCreateWithoutTestcasesInput
  >;
};

export type ProblemUpsertWithoutTestcasesInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutTestcasesInput,
    Prisma.ProblemUncheckedUpdateWithoutTestcasesInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutTestcasesInput,
    Prisma.ProblemUncheckedCreateWithoutTestcasesInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutTestcasesInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutTestcasesInput,
    Prisma.ProblemUncheckedUpdateWithoutTestcasesInput
  >;
};

export type ProblemUpdateWithoutTestcasesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutTestcasesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutHintsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutHintsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutHintsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutHintsInput,
    Prisma.ProblemUncheckedCreateWithoutHintsInput
  >;
};

export type ProblemUpsertWithoutHintsInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutHintsInput,
    Prisma.ProblemUncheckedUpdateWithoutHintsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutHintsInput,
    Prisma.ProblemUncheckedCreateWithoutHintsInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutHintsInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutHintsInput,
    Prisma.ProblemUncheckedUpdateWithoutHintsInput
  >;
};

export type ProblemUpdateWithoutHintsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutHintsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutTopicsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutTopicsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutTopicsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutTopicsInput,
    Prisma.ProblemUncheckedCreateWithoutTopicsInput
  >;
};

export type ProblemUpsertWithWhereUniqueWithoutTopicsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutTopicsInput,
    Prisma.ProblemUncheckedUpdateWithoutTopicsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutTopicsInput,
    Prisma.ProblemUncheckedCreateWithoutTopicsInput
  >;
};

export type ProblemUpdateWithWhereUniqueWithoutTopicsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutTopicsInput,
    Prisma.ProblemUncheckedUpdateWithoutTopicsInput
  >;
};

export type ProblemUpdateManyWithWhereWithoutTopicsInput = {
  where: Prisma.ProblemScalarWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateManyMutationInput,
    Prisma.ProblemUncheckedUpdateManyWithoutTopicsInput
  >;
};

export type ProblemCreateWithoutProblemInteractionInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutProblemInteractionInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutProblemInteractionInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutProblemInteractionInput,
    Prisma.ProblemUncheckedCreateWithoutProblemInteractionInput
  >;
};

export type ProblemUpsertWithoutProblemInteractionInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutProblemInteractionInput,
    Prisma.ProblemUncheckedUpdateWithoutProblemInteractionInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutProblemInteractionInput,
    Prisma.ProblemUncheckedCreateWithoutProblemInteractionInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutProblemInteractionInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutProblemInteractionInput,
    Prisma.ProblemUncheckedUpdateWithoutProblemInteractionInput
  >;
};

export type ProblemUpdateWithoutProblemInteractionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutProblemInteractionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutBookmarkedProblemsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutBookmarkedProblemsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutBookmarkedProblemsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutBookmarkedProblemsInput,
    Prisma.ProblemUncheckedCreateWithoutBookmarkedProblemsInput
  >;
};

export type ProblemUpsertWithoutBookmarkedProblemsInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutBookmarkedProblemsInput,
    Prisma.ProblemUncheckedUpdateWithoutBookmarkedProblemsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutBookmarkedProblemsInput,
    Prisma.ProblemUncheckedCreateWithoutBookmarkedProblemsInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutBookmarkedProblemsInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutBookmarkedProblemsInput,
    Prisma.ProblemUncheckedUpdateWithoutBookmarkedProblemsInput
  >;
};

export type ProblemUpdateWithoutBookmarkedProblemsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutBookmarkedProblemsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutExamplesInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutExamplesInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutExamplesInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutExamplesInput,
    Prisma.ProblemUncheckedCreateWithoutExamplesInput
  >;
};

export type ProblemUpsertWithoutExamplesInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutExamplesInput,
    Prisma.ProblemUncheckedUpdateWithoutExamplesInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutExamplesInput,
    Prisma.ProblemUncheckedCreateWithoutExamplesInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutExamplesInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutExamplesInput,
    Prisma.ProblemUncheckedUpdateWithoutExamplesInput
  >;
};

export type ProblemUpdateWithoutExamplesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutExamplesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutSolutionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutSolutionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutSolutionsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutSolutionsInput
  >;
};

export type ProblemUpsertWithoutSolutionsInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutSolutionsInput,
    Prisma.ProblemUncheckedUpdateWithoutSolutionsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutSolutionsInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutSolutionsInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutSolutionsInput,
    Prisma.ProblemUncheckedUpdateWithoutSolutionsInput
  >;
};

export type ProblemUpdateWithoutSolutionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutSolutionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutSubmissionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutSubmissionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutSubmissionsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutSubmissionsInput,
    Prisma.ProblemUncheckedCreateWithoutSubmissionsInput
  >;
};

export type ProblemUpsertWithoutSubmissionsInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutSubmissionsInput,
    Prisma.ProblemUncheckedUpdateWithoutSubmissionsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutSubmissionsInput,
    Prisma.ProblemUncheckedCreateWithoutSubmissionsInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutSubmissionsInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutSubmissionsInput,
    Prisma.ProblemUncheckedUpdateWithoutSubmissionsInput
  >;
};

export type ProblemUpdateWithoutSubmissionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutSubmissionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutUserSolutionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutUserSolutionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutUserSolutionsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutUserSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutUserSolutionsInput
  >;
};

export type ProblemUpsertWithoutUserSolutionsInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutUserSolutionsInput,
    Prisma.ProblemUncheckedUpdateWithoutUserSolutionsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutUserSolutionsInput,
    Prisma.ProblemUncheckedCreateWithoutUserSolutionsInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutUserSolutionsInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutUserSolutionsInput,
    Prisma.ProblemUncheckedUpdateWithoutUserSolutionsInput
  >;
};

export type ProblemUpdateWithoutUserSolutionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutUserSolutionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutEditorialInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  discussions?: Prisma.DiscussionCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutEditorialInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  discussions?: Prisma.DiscussionUncheckedCreateNestedManyWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutEditorialInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutEditorialInput,
    Prisma.ProblemUncheckedCreateWithoutEditorialInput
  >;
};

export type ProblemUpsertWithoutEditorialInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutEditorialInput,
    Prisma.ProblemUncheckedUpdateWithoutEditorialInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutEditorialInput,
    Prisma.ProblemUncheckedCreateWithoutEditorialInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutEditorialInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutEditorialInput,
    Prisma.ProblemUncheckedUpdateWithoutEditorialInput
  >;
};

export type ProblemUpdateWithoutEditorialInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutEditorialInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateWithoutDiscussionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleCreateNestedManyWithoutProblemInput;
  createdBy?: Prisma.UserCreateNestedOneWithoutProblemsInput;
  solutions?: Prisma.SolutionCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialCreateNestedOneWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseCreateNestedManyWithoutProblemInput;
};

export type ProblemUncheckedCreateWithoutDiscussionsInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  createdById?: string | null;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  examples?: Prisma.ExampleUncheckedCreateNestedManyWithoutProblemInput;
  solutions?: Prisma.SolutionUncheckedCreateNestedManyWithoutProblemInput;
  submissions?: Prisma.SubmissionUncheckedCreateNestedManyWithoutProblemInput;
  userSolutions?: Prisma.UserSolutionUncheckedCreateNestedManyWithoutProblemInput;
  hints?: Prisma.HintUncheckedCreateNestedManyWithoutProblemInput;
  topics?: Prisma.TopicUncheckedCreateNestedManyWithoutProblemsInput;
  editorial?: Prisma.EditorialUncheckedCreateNestedOneWithoutProblemInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedCreateNestedManyWithoutProblemInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedCreateNestedManyWithoutProblemInput;
  testcases?: Prisma.TestcaseUncheckedCreateNestedManyWithoutProblemInput;
};

export type ProblemCreateOrConnectWithoutDiscussionsInput = {
  where: Prisma.ProblemWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutDiscussionsInput,
    Prisma.ProblemUncheckedCreateWithoutDiscussionsInput
  >;
};

export type ProblemUpsertWithoutDiscussionsInput = {
  update: Prisma.XOR<
    Prisma.ProblemUpdateWithoutDiscussionsInput,
    Prisma.ProblemUncheckedUpdateWithoutDiscussionsInput
  >;
  create: Prisma.XOR<
    Prisma.ProblemCreateWithoutDiscussionsInput,
    Prisma.ProblemUncheckedCreateWithoutDiscussionsInput
  >;
  where?: Prisma.ProblemWhereInput;
};

export type ProblemUpdateToOneWithWhereWithoutDiscussionsInput = {
  where?: Prisma.ProblemWhereInput;
  data: Prisma.XOR<
    Prisma.ProblemUpdateWithoutDiscussionsInput,
    Prisma.ProblemUncheckedUpdateWithoutDiscussionsInput
  >;
};

export type ProblemUpdateWithoutDiscussionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutDiscussionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemCreateManyCreatedByInput = {
  id?: string;
  title: string;
  slug: string;
  description: string;
  timeLimitInSeconds: number;
  memoryLimitInMB: number;
  views?: number;
  acceptedSubmissions?: number;
  totalSubmissions?: number;
  difficulty: $Enums.Difficulty;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type ProblemUpdateWithoutCreatedByInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutCreatedByInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  topics?: Prisma.TopicUncheckedUpdateManyWithoutProblemsNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateManyWithoutCreatedByInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type ProblemUpdateWithoutTopicsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUpdateManyWithoutProblemNestedInput;
  createdBy?: Prisma.UserUpdateOneWithoutProblemsNestedInput;
  solutions?: Prisma.SolutionUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUpdateManyWithoutProblemNestedInput;
  editorial?: Prisma.EditorialUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateWithoutTopicsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  examples?: Prisma.ExampleUncheckedUpdateManyWithoutProblemNestedInput;
  solutions?: Prisma.SolutionUncheckedUpdateManyWithoutProblemNestedInput;
  submissions?: Prisma.SubmissionUncheckedUpdateManyWithoutProblemNestedInput;
  userSolutions?: Prisma.UserSolutionUncheckedUpdateManyWithoutProblemNestedInput;
  hints?: Prisma.HintUncheckedUpdateManyWithoutProblemNestedInput;
  editorial?: Prisma.EditorialUncheckedUpdateOneWithoutProblemNestedInput;
  discussions?: Prisma.DiscussionUncheckedUpdateManyWithoutProblemNestedInput;
  problemInteraction?: Prisma.ProblemInteractionUncheckedUpdateManyWithoutProblemNestedInput;
  bookmarkedProblems?: Prisma.BookmarkedProblemUncheckedUpdateManyWithoutProblemNestedInput;
  testcases?: Prisma.TestcaseUncheckedUpdateManyWithoutProblemNestedInput;
};

export type ProblemUncheckedUpdateManyWithoutTopicsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  title?: Prisma.StringFieldUpdateOperationsInput | string;
  slug?: Prisma.StringFieldUpdateOperationsInput | string;
  description?: Prisma.StringFieldUpdateOperationsInput | string;
  createdById?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  timeLimitInSeconds?: Prisma.IntFieldUpdateOperationsInput | number;
  memoryLimitInMB?: Prisma.IntFieldUpdateOperationsInput | number;
  views?: Prisma.IntFieldUpdateOperationsInput | number;
  acceptedSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  totalSubmissions?: Prisma.IntFieldUpdateOperationsInput | number;
  difficulty?:
    | Prisma.EnumDifficultyFieldUpdateOperationsInput
    | $Enums.Difficulty;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

/**
 * Count Type ProblemCountOutputType
 */

export type ProblemCountOutputType = {
  examples: number;
  solutions: number;
  submissions: number;
  userSolutions: number;
  hints: number;
  topics: number;
  discussions: number;
  problemInteraction: number;
  bookmarkedProblems: number;
  testcases: number;
};

export type ProblemCountOutputTypeSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  examples?: boolean | ProblemCountOutputTypeCountExamplesArgs;
  solutions?: boolean | ProblemCountOutputTypeCountSolutionsArgs;
  submissions?: boolean | ProblemCountOutputTypeCountSubmissionsArgs;
  userSolutions?: boolean | ProblemCountOutputTypeCountUserSolutionsArgs;
  hints?: boolean | ProblemCountOutputTypeCountHintsArgs;
  topics?: boolean | ProblemCountOutputTypeCountTopicsArgs;
  discussions?: boolean | ProblemCountOutputTypeCountDiscussionsArgs;
  problemInteraction?:
    | boolean
    | ProblemCountOutputTypeCountProblemInteractionArgs;
  bookmarkedProblems?:
    | boolean
    | ProblemCountOutputTypeCountBookmarkedProblemsArgs;
  testcases?: boolean | ProblemCountOutputTypeCountTestcasesArgs;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ProblemCountOutputType
   */
  select?: Prisma.ProblemCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountExamplesArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ExampleWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountSolutionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.SolutionWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountSubmissionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.SubmissionWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountUserSolutionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.UserSolutionWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountHintsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.HintWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountTopicsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.TopicWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountDiscussionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.DiscussionWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountProblemInteractionArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ProblemInteractionWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountBookmarkedProblemsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.BookmarkedProblemWhereInput;
};

/**
 * ProblemCountOutputType without action
 */
export type ProblemCountOutputTypeCountTestcasesArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.TestcaseWhereInput;
};

export type ProblemSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    title?: boolean;
    slug?: boolean;
    description?: boolean;
    createdById?: boolean;
    timeLimitInSeconds?: boolean;
    memoryLimitInMB?: boolean;
    views?: boolean;
    acceptedSubmissions?: boolean;
    totalSubmissions?: boolean;
    difficulty?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    examples?: boolean | Prisma.Problem$examplesArgs<ExtArgs>;
    createdBy?: boolean | Prisma.Problem$createdByArgs<ExtArgs>;
    solutions?: boolean | Prisma.Problem$solutionsArgs<ExtArgs>;
    submissions?: boolean | Prisma.Problem$submissionsArgs<ExtArgs>;
    userSolutions?: boolean | Prisma.Problem$userSolutionsArgs<ExtArgs>;
    hints?: boolean | Prisma.Problem$hintsArgs<ExtArgs>;
    topics?: boolean | Prisma.Problem$topicsArgs<ExtArgs>;
    editorial?: boolean | Prisma.Problem$editorialArgs<ExtArgs>;
    discussions?: boolean | Prisma.Problem$discussionsArgs<ExtArgs>;
    problemInteraction?:
      | boolean
      | Prisma.Problem$problemInteractionArgs<ExtArgs>;
    bookmarkedProblems?:
      | boolean
      | Prisma.Problem$bookmarkedProblemsArgs<ExtArgs>;
    testcases?: boolean | Prisma.Problem$testcasesArgs<ExtArgs>;
    _count?: boolean | Prisma.ProblemCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["problem"]
>;

export type ProblemSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    title?: boolean;
    slug?: boolean;
    description?: boolean;
    createdById?: boolean;
    timeLimitInSeconds?: boolean;
    memoryLimitInMB?: boolean;
    views?: boolean;
    acceptedSubmissions?: boolean;
    totalSubmissions?: boolean;
    difficulty?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean | Prisma.Problem$createdByArgs<ExtArgs>;
  },
  ExtArgs["result"]["problem"]
>;

export type ProblemSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    title?: boolean;
    slug?: boolean;
    description?: boolean;
    createdById?: boolean;
    timeLimitInSeconds?: boolean;
    memoryLimitInMB?: boolean;
    views?: boolean;
    acceptedSubmissions?: boolean;
    totalSubmissions?: boolean;
    difficulty?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdBy?: boolean | Prisma.Problem$createdByArgs<ExtArgs>;
  },
  ExtArgs["result"]["problem"]
>;

export type ProblemSelectScalar = {
  id?: boolean;
  title?: boolean;
  slug?: boolean;
  description?: boolean;
  createdById?: boolean;
  timeLimitInSeconds?: boolean;
  memoryLimitInMB?: boolean;
  views?: boolean;
  acceptedSubmissions?: boolean;
  totalSubmissions?: boolean;
  difficulty?: boolean;
  createdAt?: boolean;
  updatedAt?: boolean;
};

export type ProblemOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | "id"
  | "title"
  | "slug"
  | "description"
  | "createdById"
  | "timeLimitInSeconds"
  | "memoryLimitInMB"
  | "views"
  | "acceptedSubmissions"
  | "totalSubmissions"
  | "difficulty"
  | "createdAt"
  | "updatedAt",
  ExtArgs["result"]["problem"]
>;
export type ProblemInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  examples?: boolean | Prisma.Problem$examplesArgs<ExtArgs>;
  createdBy?: boolean | Prisma.Problem$createdByArgs<ExtArgs>;
  solutions?: boolean | Prisma.Problem$solutionsArgs<ExtArgs>;
  submissions?: boolean | Prisma.Problem$submissionsArgs<ExtArgs>;
  userSolutions?: boolean | Prisma.Problem$userSolutionsArgs<ExtArgs>;
  hints?: boolean | Prisma.Problem$hintsArgs<ExtArgs>;
  topics?: boolean | Prisma.Problem$topicsArgs<ExtArgs>;
  editorial?: boolean | Prisma.Problem$editorialArgs<ExtArgs>;
  discussions?: boolean | Prisma.Problem$discussionsArgs<ExtArgs>;
  problemInteraction?: boolean | Prisma.Problem$problemInteractionArgs<ExtArgs>;
  bookmarkedProblems?: boolean | Prisma.Problem$bookmarkedProblemsArgs<ExtArgs>;
  testcases?: boolean | Prisma.Problem$testcasesArgs<ExtArgs>;
  _count?: boolean | Prisma.ProblemCountOutputTypeDefaultArgs<ExtArgs>;
};
export type ProblemIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  createdBy?: boolean | Prisma.Problem$createdByArgs<ExtArgs>;
};
export type ProblemIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  createdBy?: boolean | Prisma.Problem$createdByArgs<ExtArgs>;
};

export type $ProblemPayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  name: "Problem";
  objects: {
    examples: Prisma.$ExamplePayload<ExtArgs>[];
    createdBy: Prisma.$UserPayload<ExtArgs> | null;
    solutions: Prisma.$SolutionPayload<ExtArgs>[];
    submissions: Prisma.$SubmissionPayload<ExtArgs>[];
    userSolutions: Prisma.$UserSolutionPayload<ExtArgs>[];
    hints: Prisma.$HintPayload<ExtArgs>[];
    topics: Prisma.$TopicPayload<ExtArgs>[];
    editorial: Prisma.$EditorialPayload<ExtArgs> | null;
    discussions: Prisma.$DiscussionPayload<ExtArgs>[];
    problemInteraction: Prisma.$ProblemInteractionPayload<ExtArgs>[];
    bookmarkedProblems: Prisma.$BookmarkedProblemPayload<ExtArgs>[];
    testcases: Prisma.$TestcasePayload<ExtArgs>[];
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      title: string;
      slug: string;
      description: string;
      createdById: string | null;
      timeLimitInSeconds: number;
      memoryLimitInMB: number;
      views: number;
      acceptedSubmissions: number;
      totalSubmissions: number;
      difficulty: $Enums.Difficulty;
      createdAt: Date;
      updatedAt: Date;
    },
    ExtArgs["result"]["problem"]
  >;
  composites: {};
};

export type ProblemGetPayload<
  S extends boolean | null | undefined | ProblemDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$ProblemPayload, S>;

export type ProblemCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = Omit<ProblemFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: ProblemCountAggregateInputType | true;
};

export interface ProblemDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>["model"]["Problem"];
    meta: { name: "Problem" };
  };
  /**
   * Find zero or one Problem that matches the filter.
   * @param {ProblemFindUniqueArgs} args - Arguments to find a Problem
   * @example
   * // Get one Problem
   * const problem = await prisma.problem.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProblemFindUniqueArgs>(
    args: Prisma.SelectSubset<T, ProblemFindUniqueArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Problem that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProblemFindUniqueOrThrowArgs} args - Arguments to find a Problem
   * @example
   * // Get one Problem
   * const problem = await prisma.problem.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProblemFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, ProblemFindUniqueOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Problem that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemFindFirstArgs} args - Arguments to find a Problem
   * @example
   * // Get one Problem
   * const problem = await prisma.problem.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProblemFindFirstArgs>(
    args?: Prisma.SelectSubset<T, ProblemFindFirstArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Problem that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemFindFirstOrThrowArgs} args - Arguments to find a Problem
   * @example
   * // Get one Problem
   * const problem = await prisma.problem.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProblemFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, ProblemFindFirstOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Problems that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Problems
   * const problems = await prisma.problem.findMany()
   *
   * // Get first 10 Problems
   * const problems = await prisma.problem.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const problemWithIdOnly = await prisma.problem.findMany({ select: { id: true } })
   *
   */
  findMany<T extends ProblemFindManyArgs>(
    args?: Prisma.SelectSubset<T, ProblemFindManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "findMany",
      GlobalOmitOptions
    >
  >;

  /**
   * Create a Problem.
   * @param {ProblemCreateArgs} args - Arguments to create a Problem.
   * @example
   * // Create one Problem
   * const Problem = await prisma.problem.create({
   *   data: {
   *     // ... data to create a Problem
   *   }
   * })
   *
   */
  create<T extends ProblemCreateArgs>(
    args: Prisma.SelectSubset<T, ProblemCreateArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "create",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Problems.
   * @param {ProblemCreateManyArgs} args - Arguments to create many Problems.
   * @example
   * // Create many Problems
   * const problem = await prisma.problem.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends ProblemCreateManyArgs>(
    args?: Prisma.SelectSubset<T, ProblemCreateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Problems and returns the data saved in the database.
   * @param {ProblemCreateManyAndReturnArgs} args - Arguments to create many Problems.
   * @example
   * // Create many Problems
   * const problem = await prisma.problem.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Problems and only return the `id`
   * const problemWithIdOnly = await prisma.problem.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends ProblemCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, ProblemCreateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Problem.
   * @param {ProblemDeleteArgs} args - Arguments to delete one Problem.
   * @example
   * // Delete one Problem
   * const Problem = await prisma.problem.delete({
   *   where: {
   *     // ... filter to delete one Problem
   *   }
   * })
   *
   */
  delete<T extends ProblemDeleteArgs>(
    args: Prisma.SelectSubset<T, ProblemDeleteArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "delete",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Problem.
   * @param {ProblemUpdateArgs} args - Arguments to update one Problem.
   * @example
   * // Update one Problem
   * const problem = await prisma.problem.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends ProblemUpdateArgs>(
    args: Prisma.SelectSubset<T, ProblemUpdateArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "update",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Problems.
   * @param {ProblemDeleteManyArgs} args - Arguments to filter Problems to delete.
   * @example
   * // Delete a few Problems
   * const { count } = await prisma.problem.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends ProblemDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, ProblemDeleteManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Problems.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Problems
   * const problem = await prisma.problem.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends ProblemUpdateManyArgs>(
    args: Prisma.SelectSubset<T, ProblemUpdateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Problems and returns the data updated in the database.
   * @param {ProblemUpdateManyAndReturnArgs} args - Arguments to update many Problems.
   * @example
   * // Update many Problems
   * const problem = await prisma.problem.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Problems and only return the `id`
   * const problemWithIdOnly = await prisma.problem.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends ProblemUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, ProblemUpdateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Problem.
   * @param {ProblemUpsertArgs} args - Arguments to update or create a Problem.
   * @example
   * // Update or create a Problem
   * const problem = await prisma.problem.upsert({
   *   create: {
   *     // ... data to create a Problem
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Problem we want to update
   *   }
   * })
   */
  upsert<T extends ProblemUpsertArgs>(
    args: Prisma.SelectSubset<T, ProblemUpsertArgs<ExtArgs>>
  ): Prisma.Prisma__ProblemClient<
    runtime.Types.Result.GetResult<
      Prisma.$ProblemPayload<ExtArgs>,
      T,
      "upsert",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Problems.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemCountArgs} args - Arguments to filter Problems to count.
   * @example
   * // Count the number of Problems
   * const count = await prisma.problem.count({
   *   where: {
   *     // ... the filter for the Problems we want to count
   *   }
   * })
   **/
  count<T extends ProblemCountArgs>(
    args?: Prisma.Subset<T, ProblemCountArgs>
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], ProblemCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Problem.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends ProblemAggregateArgs>(
    args: Prisma.Subset<T, ProblemAggregateArgs>
  ): Prisma.PrismaPromise<GetProblemAggregateType<T>>;

  /**
   * Group by Problem.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProblemGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends ProblemGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProblemGroupByArgs["orderBy"] }
      : { orderBy?: ProblemGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    "Field ",
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, ProblemGroupByArgs, OrderByArg> &
      InputErrors
  ): {} extends InputErrors
    ? GetProblemGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Problem model
   */
  readonly fields: ProblemFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Problem.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProblemClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  examples<T extends Prisma.Problem$examplesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$examplesArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ExamplePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  createdBy<T extends Prisma.Problem$createdByArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$createdByArgs<ExtArgs>>
  ): Prisma.Prisma__UserClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  solutions<T extends Prisma.Problem$solutionsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$solutionsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$SolutionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  submissions<T extends Prisma.Problem$submissionsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$submissionsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  userSolutions<T extends Prisma.Problem$userSolutionsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$userSolutionsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$UserSolutionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  hints<T extends Prisma.Problem$hintsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$hintsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$HintPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  topics<T extends Prisma.Problem$topicsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$topicsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$TopicPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  editorial<T extends Prisma.Problem$editorialArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$editorialArgs<ExtArgs>>
  ): Prisma.Prisma__EditorialClient<
    runtime.Types.Result.GetResult<
      Prisma.$EditorialPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  discussions<T extends Prisma.Problem$discussionsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$discussionsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$DiscussionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  problemInteraction<
    T extends Prisma.Problem$problemInteractionArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Problem$problemInteractionArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ProblemInteractionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  bookmarkedProblems<
    T extends Prisma.Problem$bookmarkedProblemsArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Problem$bookmarkedProblemsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$BookmarkedProblemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  testcases<T extends Prisma.Problem$testcasesArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Problem$testcasesArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$TestcasePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Problem model
 */
export interface ProblemFieldRefs {
  readonly id: Prisma.FieldRef<"Problem", "String">;
  readonly title: Prisma.FieldRef<"Problem", "String">;
  readonly slug: Prisma.FieldRef<"Problem", "String">;
  readonly description: Prisma.FieldRef<"Problem", "String">;
  readonly createdById: Prisma.FieldRef<"Problem", "String">;
  readonly timeLimitInSeconds: Prisma.FieldRef<"Problem", "Int">;
  readonly memoryLimitInMB: Prisma.FieldRef<"Problem", "Int">;
  readonly views: Prisma.FieldRef<"Problem", "Int">;
  readonly acceptedSubmissions: Prisma.FieldRef<"Problem", "Int">;
  readonly totalSubmissions: Prisma.FieldRef<"Problem", "Int">;
  readonly difficulty: Prisma.FieldRef<"Problem", "Difficulty">;
  readonly createdAt: Prisma.FieldRef<"Problem", "DateTime">;
  readonly updatedAt: Prisma.FieldRef<"Problem", "DateTime">;
}

// Custom InputTypes
/**
 * Problem findUnique
 */
export type ProblemFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * Filter, which Problem to fetch.
   */
  where: Prisma.ProblemWhereUniqueInput;
};

/**
 * Problem findUniqueOrThrow
 */
export type ProblemFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * Filter, which Problem to fetch.
   */
  where: Prisma.ProblemWhereUniqueInput;
};

/**
 * Problem findFirst
 */
export type ProblemFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * Filter, which Problem to fetch.
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Problems to fetch.
   */
  orderBy?:
    | Prisma.ProblemOrderByWithRelationInput
    | Prisma.ProblemOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Problems.
   */
  cursor?: Prisma.ProblemWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Problems from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Problems.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Problems.
   */
  distinct?: Prisma.ProblemScalarFieldEnum | Prisma.ProblemScalarFieldEnum[];
};

/**
 * Problem findFirstOrThrow
 */
export type ProblemFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * Filter, which Problem to fetch.
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Problems to fetch.
   */
  orderBy?:
    | Prisma.ProblemOrderByWithRelationInput
    | Prisma.ProblemOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Problems.
   */
  cursor?: Prisma.ProblemWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Problems from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Problems.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Problems.
   */
  distinct?: Prisma.ProblemScalarFieldEnum | Prisma.ProblemScalarFieldEnum[];
};

/**
 * Problem findMany
 */
export type ProblemFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * Filter, which Problems to fetch.
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Problems to fetch.
   */
  orderBy?:
    | Prisma.ProblemOrderByWithRelationInput
    | Prisma.ProblemOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Problems.
   */
  cursor?: Prisma.ProblemWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Problems from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Problems.
   */
  skip?: number;
  distinct?: Prisma.ProblemScalarFieldEnum | Prisma.ProblemScalarFieldEnum[];
};

/**
 * Problem create
 */
export type ProblemCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * The data needed to create a Problem.
   */
  data: Prisma.XOR<
    Prisma.ProblemCreateInput,
    Prisma.ProblemUncheckedCreateInput
  >;
};

/**
 * Problem createMany
 */
export type ProblemCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many Problems.
   */
  data: Prisma.ProblemCreateManyInput | Prisma.ProblemCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Problem createManyAndReturn
 */
export type ProblemCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * The data used to create many Problems.
   */
  data: Prisma.ProblemCreateManyInput | Prisma.ProblemCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Problem update
 */
export type ProblemUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * The data needed to update a Problem.
   */
  data: Prisma.XOR<
    Prisma.ProblemUpdateInput,
    Prisma.ProblemUncheckedUpdateInput
  >;
  /**
   * Choose, which Problem to update.
   */
  where: Prisma.ProblemWhereUniqueInput;
};

/**
 * Problem updateMany
 */
export type ProblemUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update Problems.
   */
  data: Prisma.XOR<
    Prisma.ProblemUpdateManyMutationInput,
    Prisma.ProblemUncheckedUpdateManyInput
  >;
  /**
   * Filter which Problems to update
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * Limit how many Problems to update.
   */
  limit?: number;
};

/**
 * Problem updateManyAndReturn
 */
export type ProblemUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * The data used to update Problems.
   */
  data: Prisma.XOR<
    Prisma.ProblemUpdateManyMutationInput,
    Prisma.ProblemUncheckedUpdateManyInput
  >;
  /**
   * Filter which Problems to update
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * Limit how many Problems to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Problem upsert
 */
export type ProblemUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * The filter to search for the Problem to update in case it exists.
   */
  where: Prisma.ProblemWhereUniqueInput;
  /**
   * In case the Problem found by the `where` argument doesn't exist, create a new Problem with this data.
   */
  create: Prisma.XOR<
    Prisma.ProblemCreateInput,
    Prisma.ProblemUncheckedCreateInput
  >;
  /**
   * In case the Problem was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.ProblemUpdateInput,
    Prisma.ProblemUncheckedUpdateInput
  >;
};

/**
 * Problem delete
 */
export type ProblemDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
  /**
   * Filter which Problem to delete.
   */
  where: Prisma.ProblemWhereUniqueInput;
};

/**
 * Problem deleteMany
 */
export type ProblemDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Problems to delete
   */
  where?: Prisma.ProblemWhereInput;
  /**
   * Limit how many Problems to delete.
   */
  limit?: number;
};

/**
 * Problem.examples
 */
export type Problem$examplesArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Example
   */
  select?: Prisma.ExampleSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Example
   */
  omit?: Prisma.ExampleOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ExampleInclude<ExtArgs> | null;
  where?: Prisma.ExampleWhereInput;
  orderBy?:
    | Prisma.ExampleOrderByWithRelationInput
    | Prisma.ExampleOrderByWithRelationInput[];
  cursor?: Prisma.ExampleWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.ExampleScalarFieldEnum | Prisma.ExampleScalarFieldEnum[];
};

/**
 * Problem.createdBy
 */
export type Problem$createdByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null;
  where?: Prisma.UserWhereInput;
};

/**
 * Problem.solutions
 */
export type Problem$solutionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Solution
   */
  select?: Prisma.SolutionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Solution
   */
  omit?: Prisma.SolutionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SolutionInclude<ExtArgs> | null;
  where?: Prisma.SolutionWhereInput;
  orderBy?:
    | Prisma.SolutionOrderByWithRelationInput
    | Prisma.SolutionOrderByWithRelationInput[];
  cursor?: Prisma.SolutionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.SolutionScalarFieldEnum | Prisma.SolutionScalarFieldEnum[];
};

/**
 * Problem.submissions
 */
export type Problem$submissionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Submission
   */
  select?: Prisma.SubmissionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Submission
   */
  omit?: Prisma.SubmissionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubmissionInclude<ExtArgs> | null;
  where?: Prisma.SubmissionWhereInput;
  orderBy?:
    | Prisma.SubmissionOrderByWithRelationInput
    | Prisma.SubmissionOrderByWithRelationInput[];
  cursor?: Prisma.SubmissionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.SubmissionScalarFieldEnum
    | Prisma.SubmissionScalarFieldEnum[];
};

/**
 * Problem.userSolutions
 */
export type Problem$userSolutionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the UserSolution
   */
  select?: Prisma.UserSolutionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the UserSolution
   */
  omit?: Prisma.UserSolutionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserSolutionInclude<ExtArgs> | null;
  where?: Prisma.UserSolutionWhereInput;
  orderBy?:
    | Prisma.UserSolutionOrderByWithRelationInput
    | Prisma.UserSolutionOrderByWithRelationInput[];
  cursor?: Prisma.UserSolutionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.UserSolutionScalarFieldEnum
    | Prisma.UserSolutionScalarFieldEnum[];
};

/**
 * Problem.hints
 */
export type Problem$hintsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Hint
   */
  select?: Prisma.HintSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Hint
   */
  omit?: Prisma.HintOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.HintInclude<ExtArgs> | null;
  where?: Prisma.HintWhereInput;
  orderBy?:
    | Prisma.HintOrderByWithRelationInput
    | Prisma.HintOrderByWithRelationInput[];
  cursor?: Prisma.HintWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.HintScalarFieldEnum | Prisma.HintScalarFieldEnum[];
};

/**
 * Problem.topics
 */
export type Problem$topicsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Topic
   */
  select?: Prisma.TopicSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Topic
   */
  omit?: Prisma.TopicOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TopicInclude<ExtArgs> | null;
  where?: Prisma.TopicWhereInput;
  orderBy?:
    | Prisma.TopicOrderByWithRelationInput
    | Prisma.TopicOrderByWithRelationInput[];
  cursor?: Prisma.TopicWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.TopicScalarFieldEnum | Prisma.TopicScalarFieldEnum[];
};

/**
 * Problem.editorial
 */
export type Problem$editorialArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Editorial
   */
  select?: Prisma.EditorialSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Editorial
   */
  omit?: Prisma.EditorialOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EditorialInclude<ExtArgs> | null;
  where?: Prisma.EditorialWhereInput;
};

/**
 * Problem.discussions
 */
export type Problem$discussionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Discussion
   */
  select?: Prisma.DiscussionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Discussion
   */
  omit?: Prisma.DiscussionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DiscussionInclude<ExtArgs> | null;
  where?: Prisma.DiscussionWhereInput;
  orderBy?:
    | Prisma.DiscussionOrderByWithRelationInput
    | Prisma.DiscussionOrderByWithRelationInput[];
  cursor?: Prisma.DiscussionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.DiscussionScalarFieldEnum
    | Prisma.DiscussionScalarFieldEnum[];
};

/**
 * Problem.problemInteraction
 */
export type Problem$problemInteractionArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ProblemInteraction
   */
  select?: Prisma.ProblemInteractionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the ProblemInteraction
   */
  omit?: Prisma.ProblemInteractionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInteractionInclude<ExtArgs> | null;
  where?: Prisma.ProblemInteractionWhereInput;
  orderBy?:
    | Prisma.ProblemInteractionOrderByWithRelationInput
    | Prisma.ProblemInteractionOrderByWithRelationInput[];
  cursor?: Prisma.ProblemInteractionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.ProblemInteractionScalarFieldEnum
    | Prisma.ProblemInteractionScalarFieldEnum[];
};

/**
 * Problem.bookmarkedProblems
 */
export type Problem$bookmarkedProblemsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the BookmarkedProblem
   */
  select?: Prisma.BookmarkedProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the BookmarkedProblem
   */
  omit?: Prisma.BookmarkedProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BookmarkedProblemInclude<ExtArgs> | null;
  where?: Prisma.BookmarkedProblemWhereInput;
  orderBy?:
    | Prisma.BookmarkedProblemOrderByWithRelationInput
    | Prisma.BookmarkedProblemOrderByWithRelationInput[];
  cursor?: Prisma.BookmarkedProblemWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.BookmarkedProblemScalarFieldEnum
    | Prisma.BookmarkedProblemScalarFieldEnum[];
};

/**
 * Problem.testcases
 */
export type Problem$testcasesArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Testcase
   */
  select?: Prisma.TestcaseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Testcase
   */
  omit?: Prisma.TestcaseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TestcaseInclude<ExtArgs> | null;
  where?: Prisma.TestcaseWhereInput;
  orderBy?:
    | Prisma.TestcaseOrderByWithRelationInput
    | Prisma.TestcaseOrderByWithRelationInput[];
  cursor?: Prisma.TestcaseWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.TestcaseScalarFieldEnum | Prisma.TestcaseScalarFieldEnum[];
};

/**
 * Problem without action
 */
export type ProblemDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Problem
   */
  select?: Prisma.ProblemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Problem
   */
  omit?: Prisma.ProblemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProblemInclude<ExtArgs> | null;
};
